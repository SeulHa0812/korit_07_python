## collections
1. list : 
   - 추가 / 수정 / 삭제가 언제나 가능 
   - 순서 있음 
   - 자료형이 다르더라도 하나의 리스트에 저장 가능

   1. minus index 있음
   2. slicing-'시작인덱스:종료인덱스:증감값'
   3. list element 추가 / 삭제
   - .append() - 항상 마지막 인덱스에 element 추가
   - .inset(위치, 값) - 정해진 위치(인덱스)에 해당 값 추가
   - .pop() - call3()=삭제한 element return, 맨 마지막 요소 삭제
   - .pop(index number) - 해당 인덱스 마지막 요소 삭제
   - .remove() - 해당값 삭제 / no return

2. tuple : 
   - 저장된 값을 변경할 수 없는 list
   - 순서 있기 때문에 index 넘버와 slicing 가능 
   - but 저장된 값 이외에 추가 / 수정 / 삭제 불가능
   - 소괄호 통해서 생성
```python
tu1 = (1, 2, 3) # 생성 방법 1
tu2 = tuple((4, 5, 6)) # 생성 방법 2
tu3 = 7, 8, 9 # 생성 방법 3 - 근데 얘는 변수 하나에 데이터가 여러개
```

3. set : (집합, 자바에서와 같음)
```python
set1 = {1,2,3} # 세트 생성 방법 #1
set2 =  set({4,5,6}) # 세트 생성 방법 #2

# 굳이 # 1, 2를 나눈 이유 : 비어있는 list /tuple/set 생성 방법
li = []
tu = ()
se = {}
se2 = set({})

print(type(li)) # result : <class 'list'>
print(type(tu)) # result : <class 'tuple'>
print(type(se)) # result : <class 'dict'>
print(type(se2)) # result : <class 'set'>
```
    list / tuple은 index 존재. 이 두개를 sequence라고 하고, set / dictionary 의 경우에는 index가 없어서 비시퀀스라는 표현을 씀. 슬라이싱 없음
        element 관련 메서드
        1. .add() - set에 새로운 element 추가
        2. .remove() - 기존 element 삭제
        3. .discard() - 기존 element 삭제
      # remove() vs. discard()
         se3.remove(70) # 오류 발생 - '값을 정확하게 입력'해야만 한다고 했기 때문
         se3.discard(70) # 오류 방생 x / 정확한 값 없으면 그냥 종료

4. dict(dictionary) - Java에서의 Map / JS에서의 Object / JSON과 같은 형식


```python
# 응용 예제 5
contact_info = {}
for i in range(3):
    name = input(f'{i+1} 번째 사람의 이름을 입력하세요 >>> ')
    number = input(f'{i+1} 번째 사람의 연락처를 입력하세요 >>> ')
    contact_info[name] = number
print(f'입력 받은 연락처는 {contact_info}입니다.')
```